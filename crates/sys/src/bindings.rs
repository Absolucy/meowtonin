/* automatically generated by rust-bindgen 0.71.1 */

pub const s1cMAX: u32 = 127;
pub const s1cMIN: i32 = -127;
pub const s2cMAX: u32 = 32767;
pub const s2cMIN: i32 = -32767;
pub const s4cMAX: u32 = 2147483647;
pub const s4cMIN: i32 = -2147483647;
pub type u1c = u8;
pub type s1c = i8;
pub type u2c = u16;
pub type s2c = i16;
pub type u4c = u32;
pub type s4c = i32;
pub type u8c = u64;
pub type s8c = i64;
#[repr(C)]
#[derive(Copy, Clone)]
pub union u4cOrPointer {
	pub num: u4c,
	pub ptr: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
	["Size of u4cOrPointer"][::std::mem::size_of::<u4cOrPointer>() - 4usize];
	["Alignment of u4cOrPointer"][::std::mem::align_of::<u4cOrPointer>() - 4usize];
	["Offset of field: u4cOrPointer::num"][::std::mem::offset_of!(u4cOrPointer, num) - 0usize];
	["Offset of field: u4cOrPointer::ptr"][::std::mem::offset_of!(u4cOrPointer, ptr) - 0usize];
};
impl Default for u4cOrPointer {
	fn default() -> Self {
		let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
		unsafe {
			::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
			s.assume_init()
		}
	}
}
pub type ByondValueType = u1c;
#[repr(C)]
#[derive(Copy, Clone)]
pub union ByondValueData {
	#[doc = "!< 4-byte reference ID"]
	pub ref_: u4c,
	#[doc = "!< floating-point number"]
	pub num: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
	["Size of ByondValueData"][::std::mem::size_of::<ByondValueData>() - 4usize];
	["Alignment of ByondValueData"][::std::mem::align_of::<ByondValueData>() - 4usize];
	["Offset of field: ByondValueData::ref_"]
		[::std::mem::offset_of!(ByondValueData, ref_) - 0usize];
	["Offset of field: ByondValueData::num"][::std::mem::offset_of!(ByondValueData, num) - 0usize];
};
impl Default for ByondValueData {
	fn default() -> Self {
		let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
		unsafe {
			::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
			s.assume_init()
		}
	}
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CByondValue {
	#[doc = "!< 1-byte intrinsic data type"]
	pub type_: ByondValueType,
	#[doc = "!< padding"]
	pub junk1: u1c,
	#[doc = "!< padding"]
	pub junk2: u1c,
	#[doc = "!< padding"]
	pub junk3: u1c,
	#[doc = "!< 4-byte reference ID or floating point number"]
	pub data: ByondValueData,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
	["Size of CByondValue"][::std::mem::size_of::<CByondValue>() - 8usize];
	["Alignment of CByondValue"][::std::mem::align_of::<CByondValue>() - 4usize];
	["Offset of field: CByondValue::type_"][::std::mem::offset_of!(CByondValue, type_) - 0usize];
	["Offset of field: CByondValue::junk1"][::std::mem::offset_of!(CByondValue, junk1) - 1usize];
	["Offset of field: CByondValue::junk2"][::std::mem::offset_of!(CByondValue, junk2) - 2usize];
	["Offset of field: CByondValue::junk3"][::std::mem::offset_of!(CByondValue, junk3) - 3usize];
	["Offset of field: CByondValue::data"][::std::mem::offset_of!(CByondValue, data) - 4usize];
};
impl Default for CByondValue {
	fn default() -> Self {
		let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
		unsafe {
			::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
			s.assume_init()
		}
	}
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CByondXYZ {
	#[doc = "!< signed 2-byte integer coordinates"]
	pub x: s2c,
	#[doc = "!< signed 2-byte integer coordinates"]
	pub y: s2c,
	#[doc = "!< signed 2-byte integer coordinates"]
	pub z: s2c,
	#[doc = "!< padding"]
	pub junk: s2c,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
	["Size of CByondXYZ"][::std::mem::size_of::<CByondXYZ>() - 8usize];
	["Alignment of CByondXYZ"][::std::mem::align_of::<CByondXYZ>() - 2usize];
	["Offset of field: CByondXYZ::x"][::std::mem::offset_of!(CByondXYZ, x) - 0usize];
	["Offset of field: CByondXYZ::y"][::std::mem::offset_of!(CByondXYZ, y) - 2usize];
	["Offset of field: CByondXYZ::z"][::std::mem::offset_of!(CByondXYZ, z) - 4usize];
	["Offset of field: CByondXYZ::junk"][::std::mem::offset_of!(CByondXYZ, junk) - 6usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CByondPixLoc {
	#[doc = "!< pixel coordinates as floats"]
	pub x: f32,
	#[doc = "!< pixel coordinates as floats"]
	pub y: f32,
	#[doc = "!< signed 2-byte integer coordinates"]
	pub z: s2c,
	#[doc = "!< padding"]
	pub junk: s2c,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
	["Size of CByondPixLoc"][::std::mem::size_of::<CByondPixLoc>() - 12usize];
	["Alignment of CByondPixLoc"][::std::mem::align_of::<CByondPixLoc>() - 4usize];
	["Offset of field: CByondPixLoc::x"][::std::mem::offset_of!(CByondPixLoc, x) - 0usize];
	["Offset of field: CByondPixLoc::y"][::std::mem::offset_of!(CByondPixLoc, y) - 4usize];
	["Offset of field: CByondPixLoc::z"][::std::mem::offset_of!(CByondPixLoc, z) - 8usize];
	["Offset of field: CByondPixLoc::junk"][::std::mem::offset_of!(CByondPixLoc, junk) - 10usize];
};
pub type ByondCallback = ::std::option::Option<
	unsafe extern "C-unwind" fn(arg1: *mut ::std::os::raw::c_void) -> CByondValue,
>;
pub struct ByondApi {
	__library: ::libloading::Library,
	pub Byond_LastError: unsafe extern "C-unwind" fn() -> *const ::std::os::raw::c_char,
	pub Byond_GetVersion: unsafe extern "C-unwind" fn(version: *mut u4c, build: *mut u4c),
	pub Byond_GetDMBVersion: unsafe extern "C-unwind" fn() -> u4c,
	pub ByondValue_Clear: unsafe extern "C-unwind" fn(v: *mut CByondValue),
	pub ByondValue_Type: unsafe extern "C-unwind" fn(v: *const CByondValue) -> ByondValueType,
	pub ByondValue_IsNull: unsafe extern "C-unwind" fn(v: *const CByondValue) -> bool,
	pub ByondValue_IsNum: unsafe extern "C-unwind" fn(v: *const CByondValue) -> bool,
	pub ByondValue_IsStr: unsafe extern "C-unwind" fn(v: *const CByondValue) -> bool,
	pub ByondValue_IsList: unsafe extern "C-unwind" fn(v: *const CByondValue) -> bool,
	pub ByondValue_IsTrue: unsafe extern "C-unwind" fn(v: *const CByondValue) -> bool,
	pub ByondValue_GetNum: unsafe extern "C-unwind" fn(v: *const CByondValue) -> f32,
	pub ByondValue_GetRef: unsafe extern "C-unwind" fn(v: *const CByondValue) -> u4c,
	pub ByondValue_SetNum: unsafe extern "C-unwind" fn(v: *mut CByondValue, f: f32),
	pub ByondValue_SetStr:
		unsafe extern "C-unwind" fn(v: *mut CByondValue, str_: *const ::std::os::raw::c_char),
	pub ByondValue_SetStrId: unsafe extern "C-unwind" fn(v: *mut CByondValue, strid: u4c),
	pub ByondValue_SetRef:
		unsafe extern "C-unwind" fn(v: *mut CByondValue, type_: ByondValueType, ref_: u4c),
	pub ByondValue_Equals:
		unsafe extern "C-unwind" fn(a: *const CByondValue, b: *const CByondValue) -> bool,
	pub Byond_ThreadSync: unsafe extern "C-unwind" fn(
		callback: ByondCallback,
		data: *mut ::std::os::raw::c_void,
		block: bool,
	) -> CByondValue,
	pub Byond_GetStrId: unsafe extern "C-unwind" fn(str_: *const ::std::os::raw::c_char) -> u4c,
	pub Byond_AddGetStrId: unsafe extern "C-unwind" fn(str_: *const ::std::os::raw::c_char) -> u4c,
	pub Byond_ReadVar: unsafe extern "C-unwind" fn(
		loc: *const CByondValue,
		varname: *const ::std::os::raw::c_char,
		result: *mut CByondValue,
	) -> bool,
	pub Byond_ReadVarByStrId: unsafe extern "C-unwind" fn(
		loc: *const CByondValue,
		varname: u4c,
		result: *mut CByondValue,
	) -> bool,
	pub Byond_WriteVar: unsafe extern "C-unwind" fn(
		loc: *const CByondValue,
		varname: *const ::std::os::raw::c_char,
		val: *const CByondValue,
	) -> bool,
	pub Byond_WriteVarByStrId: unsafe extern "C-unwind" fn(
		loc: *const CByondValue,
		varname: u4c,
		val: *const CByondValue,
	) -> bool,
	pub Byond_CreateList: unsafe extern "C-unwind" fn(result: *mut CByondValue) -> bool,
	pub Byond_ReadList: unsafe extern "C-unwind" fn(
		loc: *const CByondValue,
		list: *mut CByondValue,
		len: *mut u4c,
	) -> bool,
	pub Byond_WriteList: unsafe extern "C-unwind" fn(
		loc: *const CByondValue,
		list: *const CByondValue,
		len: u4c,
	) -> bool,
	pub Byond_ReadListAssoc: unsafe extern "C-unwind" fn(
		loc: *const CByondValue,
		list: *mut CByondValue,
		len: *mut u4c,
	) -> bool,
	pub Byond_ReadListIndex: unsafe extern "C-unwind" fn(
		loc: *const CByondValue,
		idx: *const CByondValue,
		result: *mut CByondValue,
	) -> bool,
	pub Byond_WriteListIndex: unsafe extern "C-unwind" fn(
		loc: *const CByondValue,
		idx: *const CByondValue,
		val: *const CByondValue,
	) -> bool,
	pub Byond_ReadPointer:
		unsafe extern "C-unwind" fn(ptr: *const CByondValue, result: *mut CByondValue) -> bool,
	pub Byond_WritePointer:
		unsafe extern "C-unwind" fn(ptr: *const CByondValue, val: *const CByondValue) -> bool,
	pub Byond_CallProc: unsafe extern "C-unwind" fn(
		src: *const CByondValue,
		name: *const ::std::os::raw::c_char,
		arg: *const CByondValue,
		arg_count: u4c,
		result: *mut CByondValue,
	) -> bool,
	pub Byond_CallProcByStrId: unsafe extern "C-unwind" fn(
		src: *const CByondValue,
		name: u4c,
		arg: *const CByondValue,
		arg_count: u4c,
		result: *mut CByondValue,
	) -> bool,
	pub Byond_CallGlobalProc: unsafe extern "C-unwind" fn(
		name: *const ::std::os::raw::c_char,
		arg: *const CByondValue,
		arg_count: u4c,
		result: *mut CByondValue,
	) -> bool,
	pub Byond_CallGlobalProcByStrId: unsafe extern "C-unwind" fn(
		name: u4c,
		arg: *const CByondValue,
		arg_count: u4c,
		result: *mut CByondValue,
	) -> bool,
	pub Byond_ToString: unsafe extern "C-unwind" fn(
		src: *const CByondValue,
		buf: *mut ::std::os::raw::c_char,
		buflen: *mut u4c,
	) -> bool,
	pub Byond_Block: unsafe extern "C-unwind" fn(
		corner1: *const CByondXYZ,
		corner2: *const CByondXYZ,
		list: *mut CByondValue,
		len: *mut u4c,
	) -> bool,
	pub Byond_Length:
		unsafe extern "C-unwind" fn(src: *const CByondValue, result: *mut CByondValue) -> bool,
	pub Byond_LocateIn: unsafe extern "C-unwind" fn(
		type_: *const CByondValue,
		list: *const CByondValue,
		result: *mut CByondValue,
	) -> bool,
	pub Byond_LocateXYZ:
		unsafe extern "C-unwind" fn(xyz: *const CByondXYZ, result: *mut CByondValue) -> bool,
	pub Byond_New: unsafe extern "C-unwind" fn(
		type_: *const CByondValue,
		arg: *const CByondValue,
		arg_count: u4c,
		result: *mut CByondValue,
	) -> bool,
	pub Byond_NewArglist: unsafe extern "C-unwind" fn(
		type_: *const CByondValue,
		arglist: *const CByondValue,
		result: *mut CByondValue,
	) -> bool,
	pub Byond_Refcount:
		unsafe extern "C-unwind" fn(src: *const CByondValue, result: *mut u4c) -> bool,
	pub Byond_XYZ:
		unsafe extern "C-unwind" fn(src: *const CByondValue, xyz: *mut CByondXYZ) -> bool,
	pub Byond_PixLoc:
		unsafe extern "C-unwind" fn(src: *const CByondValue, pixloc: *mut CByondPixLoc) -> bool,
	pub Byond_BoundPixLoc: unsafe extern "C-unwind" fn(
		src: *const CByondValue,
		dir: u1c,
		pixloc: *mut CByondPixLoc,
	) -> bool,
	pub ByondValue_IncRef: unsafe extern "C-unwind" fn(src: *const CByondValue),
	pub ByondValue_DecRef: unsafe extern "C-unwind" fn(src: *const CByondValue),
	pub ByondValue_DecTempRef: unsafe extern "C-unwind" fn(src: *const CByondValue),
	pub Byond_TestRef: unsafe extern "C-unwind" fn(src: *mut CByondValue) -> bool,
	pub Byond_CRASH: unsafe extern "C-unwind" fn(message: *const ::std::os::raw::c_char),
}
impl ByondApi {
	pub unsafe fn new<P>(path: P) -> Result<Self, ::libloading::Error>
	where
		P: AsRef<::std::ffi::OsStr>,
	{
		let library = ::libloading::Library::new(path)?;
		Self::from_library(library)
	}
	pub unsafe fn from_library<L>(library: L) -> Result<Self, ::libloading::Error>
	where
		L: Into<::libloading::Library>,
	{
		let __library = library.into();
		let Byond_LastError = __library.get(b"Byond_LastError\0").map(|sym| *sym)?;
		let Byond_GetVersion = __library.get(b"Byond_GetVersion\0").map(|sym| *sym)?;
		let Byond_GetDMBVersion = __library.get(b"Byond_GetDMBVersion\0").map(|sym| *sym)?;
		let ByondValue_Clear = __library.get(b"ByondValue_Clear\0").map(|sym| *sym)?;
		let ByondValue_Type = __library.get(b"ByondValue_Type\0").map(|sym| *sym)?;
		let ByondValue_IsNull = __library.get(b"ByondValue_IsNull\0").map(|sym| *sym)?;
		let ByondValue_IsNum = __library.get(b"ByondValue_IsNum\0").map(|sym| *sym)?;
		let ByondValue_IsStr = __library.get(b"ByondValue_IsStr\0").map(|sym| *sym)?;
		let ByondValue_IsList = __library.get(b"ByondValue_IsList\0").map(|sym| *sym)?;
		let ByondValue_IsTrue = __library.get(b"ByondValue_IsTrue\0").map(|sym| *sym)?;
		let ByondValue_GetNum = __library.get(b"ByondValue_GetNum\0").map(|sym| *sym)?;
		let ByondValue_GetRef = __library.get(b"ByondValue_GetRef\0").map(|sym| *sym)?;
		let ByondValue_SetNum = __library.get(b"ByondValue_SetNum\0").map(|sym| *sym)?;
		let ByondValue_SetStr = __library.get(b"ByondValue_SetStr\0").map(|sym| *sym)?;
		let ByondValue_SetStrId = __library.get(b"ByondValue_SetStrId\0").map(|sym| *sym)?;
		let ByondValue_SetRef = __library.get(b"ByondValue_SetRef\0").map(|sym| *sym)?;
		let ByondValue_Equals = __library.get(b"ByondValue_Equals\0").map(|sym| *sym)?;
		let Byond_ThreadSync = __library.get(b"Byond_ThreadSync\0").map(|sym| *sym)?;
		let Byond_GetStrId = __library.get(b"Byond_GetStrId\0").map(|sym| *sym)?;
		let Byond_AddGetStrId = __library.get(b"Byond_AddGetStrId\0").map(|sym| *sym)?;
		let Byond_ReadVar = __library.get(b"Byond_ReadVar\0").map(|sym| *sym)?;
		let Byond_ReadVarByStrId = __library.get(b"Byond_ReadVarByStrId\0").map(|sym| *sym)?;
		let Byond_WriteVar = __library.get(b"Byond_WriteVar\0").map(|sym| *sym)?;
		let Byond_WriteVarByStrId = __library.get(b"Byond_WriteVarByStrId\0").map(|sym| *sym)?;
		let Byond_CreateList = __library.get(b"Byond_CreateList\0").map(|sym| *sym)?;
		let Byond_ReadList = __library.get(b"Byond_ReadList\0").map(|sym| *sym)?;
		let Byond_WriteList = __library.get(b"Byond_WriteList\0").map(|sym| *sym)?;
		let Byond_ReadListAssoc = __library.get(b"Byond_ReadListAssoc\0").map(|sym| *sym)?;
		let Byond_ReadListIndex = __library.get(b"Byond_ReadListIndex\0").map(|sym| *sym)?;
		let Byond_WriteListIndex = __library.get(b"Byond_WriteListIndex\0").map(|sym| *sym)?;
		let Byond_ReadPointer = __library.get(b"Byond_ReadPointer\0").map(|sym| *sym)?;
		let Byond_WritePointer = __library.get(b"Byond_WritePointer\0").map(|sym| *sym)?;
		let Byond_CallProc = __library.get(b"Byond_CallProc\0").map(|sym| *sym)?;
		let Byond_CallProcByStrId = __library.get(b"Byond_CallProcByStrId\0").map(|sym| *sym)?;
		let Byond_CallGlobalProc = __library.get(b"Byond_CallGlobalProc\0").map(|sym| *sym)?;
		let Byond_CallGlobalProcByStrId = __library
			.get(b"Byond_CallGlobalProcByStrId\0")
			.map(|sym| *sym)?;
		let Byond_ToString = __library.get(b"Byond_ToString\0").map(|sym| *sym)?;
		let Byond_Block = __library.get(b"Byond_Block\0").map(|sym| *sym)?;
		let Byond_Length = __library.get(b"Byond_Length\0").map(|sym| *sym)?;
		let Byond_LocateIn = __library.get(b"Byond_LocateIn\0").map(|sym| *sym)?;
		let Byond_LocateXYZ = __library.get(b"Byond_LocateXYZ\0").map(|sym| *sym)?;
		let Byond_New = __library.get(b"Byond_New\0").map(|sym| *sym)?;
		let Byond_NewArglist = __library.get(b"Byond_NewArglist\0").map(|sym| *sym)?;
		let Byond_Refcount = __library.get(b"Byond_Refcount\0").map(|sym| *sym)?;
		let Byond_XYZ = __library.get(b"Byond_XYZ\0").map(|sym| *sym)?;
		let Byond_PixLoc = __library.get(b"Byond_PixLoc\0").map(|sym| *sym)?;
		let Byond_BoundPixLoc = __library.get(b"Byond_BoundPixLoc\0").map(|sym| *sym)?;
		let ByondValue_IncRef = __library.get(b"ByondValue_IncRef\0").map(|sym| *sym)?;
		let ByondValue_DecRef = __library.get(b"ByondValue_DecRef\0").map(|sym| *sym)?;
		let ByondValue_DecTempRef = __library.get(b"ByondValue_DecTempRef\0").map(|sym| *sym)?;
		let Byond_TestRef = __library.get(b"Byond_TestRef\0").map(|sym| *sym)?;
		let Byond_CRASH = __library.get(b"Byond_CRASH\0").map(|sym| *sym)?;
		Ok(ByondApi {
			__library,
			Byond_LastError,
			Byond_GetVersion,
			Byond_GetDMBVersion,
			ByondValue_Clear,
			ByondValue_Type,
			ByondValue_IsNull,
			ByondValue_IsNum,
			ByondValue_IsStr,
			ByondValue_IsList,
			ByondValue_IsTrue,
			ByondValue_GetNum,
			ByondValue_GetRef,
			ByondValue_SetNum,
			ByondValue_SetStr,
			ByondValue_SetStrId,
			ByondValue_SetRef,
			ByondValue_Equals,
			Byond_ThreadSync,
			Byond_GetStrId,
			Byond_AddGetStrId,
			Byond_ReadVar,
			Byond_ReadVarByStrId,
			Byond_WriteVar,
			Byond_WriteVarByStrId,
			Byond_CreateList,
			Byond_ReadList,
			Byond_WriteList,
			Byond_ReadListAssoc,
			Byond_ReadListIndex,
			Byond_WriteListIndex,
			Byond_ReadPointer,
			Byond_WritePointer,
			Byond_CallProc,
			Byond_CallProcByStrId,
			Byond_CallGlobalProc,
			Byond_CallGlobalProcByStrId,
			Byond_ToString,
			Byond_Block,
			Byond_Length,
			Byond_LocateIn,
			Byond_LocateXYZ,
			Byond_New,
			Byond_NewArglist,
			Byond_Refcount,
			Byond_XYZ,
			Byond_PixLoc,
			Byond_BoundPixLoc,
			ByondValue_IncRef,
			ByondValue_DecRef,
			ByondValue_DecTempRef,
			Byond_TestRef,
			Byond_CRASH,
		})
	}
	#[doc = "Gets the last error from a failed call\n The result is a static string that does not need to be freed.\n # Returns\n\nError message"]
	pub unsafe fn Byond_LastError(&self) -> *const ::std::os::raw::c_char {
		(self.Byond_LastError)()
	}
	#[doc = "Gets the current BYOND version\n # Arguments\n\n* `version` - Pointer to the major version number\n * `build` - Pointer to the build number"]
	pub unsafe fn Byond_GetVersion(&self, version: *mut u4c, build: *mut u4c) {
		(self.Byond_GetVersion)(version, build)
	}
	#[doc = "Gets the DMB version\n # Returns\n\nVersion number the .dmb was built with"]
	pub unsafe fn Byond_GetDMBVersion(&self) -> u4c {
		(self.Byond_GetDMBVersion)()
	}
	#[doc = "Fills a CByondValue struct with a null value.\n # Arguments\n\n* `v` - Pointer to CByondValue"]
	pub unsafe fn ByondValue_Clear(&self, v: *mut CByondValue) {
		(self.ByondValue_Clear)(v)
	}
	#[doc = "Reads CByondVale's 1-byte data type\n # Arguments\n\n* `v` - Pointer to CByondValue\n # Returns\n\nType of value"]
	pub unsafe fn ByondValue_Type(&self, v: *const CByondValue) -> ByondValueType {
		(self.ByondValue_Type)(v)
	}
	#[doc = "# Arguments\n\n* `v` - Pointer to CByondValue\n # Returns\n\nTrue if value is null"]
	pub unsafe fn ByondValue_IsNull(&self, v: *const CByondValue) -> bool {
		(self.ByondValue_IsNull)(v)
	}
	#[doc = "# Arguments\n\n* `v` - Pointer to CByondValue\n # Returns\n\nTrue if value is a numeric type"]
	pub unsafe fn ByondValue_IsNum(&self, v: *const CByondValue) -> bool {
		(self.ByondValue_IsNum)(v)
	}
	#[doc = "# Arguments\n\n* `v` - Pointer to CByondValue\n # Returns\n\nTrue if value is a string"]
	pub unsafe fn ByondValue_IsStr(&self, v: *const CByondValue) -> bool {
		(self.ByondValue_IsStr)(v)
	}
	#[doc = "# Arguments\n\n* `v` - Pointer to CByondValue\n # Returns\n\nTrue if value is a list (any list type, not just user-defined)"]
	pub unsafe fn ByondValue_IsList(&self, v: *const CByondValue) -> bool {
		(self.ByondValue_IsList)(v)
	}
	#[doc = "Determines if a value is logically true or false\n\n # Arguments\n\n* `v` - Pointer to CByondValue\n # Returns\n\nTruthiness of value"]
	pub unsafe fn ByondValue_IsTrue(&self, v: *const CByondValue) -> bool {
		(self.ByondValue_IsTrue)(v)
	}
	#[doc = "# Arguments\n\n* `v` - Pointer to CByondValue\n # Returns\n\nFloating point number for v, or 0 if not numeric"]
	pub unsafe fn ByondValue_GetNum(&self, v: *const CByondValue) -> f32 {
		(self.ByondValue_GetNum)(v)
	}
	#[doc = "# Arguments\n\n* `v` - Pointer to CByondValue\n # Returns\n\nReference ID if value is a reference type, or 0 otherwise"]
	pub unsafe fn ByondValue_GetRef(&self, v: *const CByondValue) -> u4c {
		(self.ByondValue_GetRef)(v)
	}
	#[doc = "Fills a CByondValue struct with a floating point number.\n # Arguments\n\n* `v` - Pointer to CByondValue\n * `f` - Floating point number"]
	pub unsafe fn ByondValue_SetNum(&self, v: *mut CByondValue, f: f32) {
		(self.ByondValue_SetNum)(v, f)
	}
	#[doc = "Creates a string and sets CByondValue to a reference to that string, and increases the reference count. See REFERENCE COUNTING in byondapi.h.\n Blocks if not on the main thread. If string creation fails, the struct is set to null.\n # Arguments\n\n* `v` - Pointer to CByondValue\n * `str` - Null-terminated UTF-8 string\n [`Byond_AddGetStrId()`]"]
	pub unsafe fn ByondValue_SetStr(
		&self,
		v: *mut CByondValue,
		str_: *const ::std::os::raw::c_char,
	) {
		(self.ByondValue_SetStr)(v, str_)
	}
	#[doc = "Fills a CByondValue struct with a reference to a string with a given ID. Does not validate, and does not increase the reference count.\n If the strid is NONE, it will be changed to 0.\n # Arguments\n\n* `v` - Pointer to CByondValue\n * `strid` - 4-byte string ID\n [`Byond_TestRef()`]"]
	pub unsafe fn ByondValue_SetStrId(&self, v: *mut CByondValue, strid: u4c) {
		(self.ByondValue_SetStrId)(v, strid)
	}
	#[doc = "Fills a CByondValue struct with a reference (object) type. Does not validate.\n # Arguments\n\n* `v` - Pointer to CByondValue\n * `type` - 1-byte teference type\n * `ref` - 4-byte reference ID; for most types, an ID of NONE is invalid\n [`Byond_TestRef()`]"]
	pub unsafe fn ByondValue_SetRef(&self, v: *mut CByondValue, type_: ByondValueType, ref_: u4c) {
		(self.ByondValue_SetRef)(v, type_, ref_)
	}
	#[doc = "Compares two values for equality\n # Arguments\n\n* `a` - Pointer to CByondValue\n * `b` - Pointer to CByondValue\n # Returns\n\nTrue if values are equal"]
	pub unsafe fn ByondValue_Equals(&self, a: *const CByondValue, b: *const CByondValue) -> bool {
		(self.ByondValue_Equals)(a, b)
	}
	#[doc = "Runs a function as a callback on the main thread (or right away if already there)\n All references created from Byondapi calls within your callback are persistent, not temporary, even though your callback runs on the main thread.\n Blocking is optional. If already on the main thread, the block parameter is meaningless.\n # Arguments\n\n* `callback` - Function pointer to CByondValue function(void*)\n * `data` - Void pointer (argument to function)\n * `block` - True if this call should block while waiting for the callback to finish; false if not\n # Returns\n\nCByondValue returned by the function (if it blocked; null if not)"]
	pub unsafe fn Byond_ThreadSync(
		&self,
		callback: ByondCallback,
		data: *mut ::std::os::raw::c_void,
		block: bool,
	) -> CByondValue {
		(self.Byond_ThreadSync)(callback, data, block)
	}
	#[doc = "Returns a reference to an existing string ID, but does not create a new string ID.\n Blocks if not on the main thread.\n # Arguments\n\n* `str` - Null-terminated string\n # Returns\n\nID of string; NONE if string does not exist"]
	pub unsafe fn Byond_GetStrId(&self, str_: *const ::std::os::raw::c_char) -> u4c {
		(self.Byond_GetStrId)(str_)
	}
	#[doc = "Returns a reference to an existing string ID or creates a new string ID reference.\n The new string is reference-counted. See REFERENCE COUNTING in byondapi.h for details.\n Call ByondValue_SeStrId() to use the returned ID in a CByondValue.\n Blocks if not on the main thread.\n # Arguments\n\n* `str` - Null-terminated string\n # Returns\n\nID of string; NONE if string creation failed"]
	pub unsafe fn Byond_AddGetStrId(&self, str_: *const ::std::os::raw::c_char) -> u4c {
		(self.Byond_AddGetStrId)(str_)
	}
	#[doc = "Reads an object variable by name.\n Blocks if not on the main thread.\n # Arguments\n\n* `loc` - Object that owns the var\n * `varname` - Var name as null-terminated string\n * `result` - Pointer to accept result\n # Returns\n\nTrue on success"]
	pub unsafe fn Byond_ReadVar(
		&self,
		loc: *const CByondValue,
		varname: *const ::std::os::raw::c_char,
		result: *mut CByondValue,
	) -> bool {
		(self.Byond_ReadVar)(loc, varname, result)
	}
	#[doc = "Reads an object variable by the string ID of its var name.\n ID can be cached ahead of time for performance.\n Blocks if not on the main thread.\n # Arguments\n\n* `loc` - Object that owns the var\n * `varname` - Var name as string ID\n * `result` - Pointer to accept result\n # Returns\n\nTrue on success\n [`Byond_GetStrId()`]"]
	pub unsafe fn Byond_ReadVarByStrId(
		&self,
		loc: *const CByondValue,
		varname: u4c,
		result: *mut CByondValue,
	) -> bool {
		(self.Byond_ReadVarByStrId)(loc, varname, result)
	}
	#[doc = "Writes an object variable by name.\n Blocks if not on the main thread.\n # Arguments\n\n* `loc` - Object that owns the var\n * `varname` - Var name as null-terminated string\n * `val` - New value\n # Returns\n\nTrue on success"]
	pub unsafe fn Byond_WriteVar(
		&self,
		loc: *const CByondValue,
		varname: *const ::std::os::raw::c_char,
		val: *const CByondValue,
	) -> bool {
		(self.Byond_WriteVar)(loc, varname, val)
	}
	#[doc = "Writes an object variable by the string ID of its var name.\n ID can be cached ahead of time for performance.\n Blocks if not on the main thread.\n # Arguments\n\n* `loc` - Object that owns the var\n * `varname` - Var name as string ID\n * `val` - New value\n # Returns\n\nTrue on success"]
	pub unsafe fn Byond_WriteVarByStrId(
		&self,
		loc: *const CByondValue,
		varname: u4c,
		val: *const CByondValue,
	) -> bool {
		(self.Byond_WriteVarByStrId)(loc, varname, val)
	}
	#[doc = "Creates an empty list with a temporary reference. Equivalent to list().\n Blocks if not on the main thread.\n # Arguments\n\n* `result` - Result\n # Returns\n\nTrue on success"]
	pub unsafe fn Byond_CreateList(&self, result: *mut CByondValue) -> bool {
		(self.Byond_CreateList)(result)
	}
	#[doc = "Reads items from a list.\n Blocks if not on the main thread.\n # Arguments\n\n* `loc` - The list to read\n * `list` - CByondValue array, allocated by caller (can be null if querying length)\n * `len` - Pointer to length of array (in items); receives the number of items read on success, or required length of array if not big enough\n # Returns\n\nTrue on success; false with *len=0 for failure; false with *len=required size if array is not big enough"]
	pub unsafe fn Byond_ReadList(
		&self,
		loc: *const CByondValue,
		list: *mut CByondValue,
		len: *mut u4c,
	) -> bool {
		(self.Byond_ReadList)(loc, list, len)
	}
	#[doc = "Writes items to a list, in place of old contents.\n Blocks if not on the main thread.\n # Arguments\n\n* `loc` - The list to fill\n * `list` - CByondValue array of items to write\n * `len` - Number of items to write\n # Returns\n\nTrue on success"]
	pub unsafe fn Byond_WriteList(
		&self,
		loc: *const CByondValue,
		list: *const CByondValue,
		len: u4c,
	) -> bool {
		(self.Byond_WriteList)(loc, list, len)
	}
	#[doc = "Reads items as key,value pairs from an associative list, storing them sequentially as key1, value1, key2, value2, etc.\n Blocks if not on the main thread.\n # Arguments\n\n* `loc` - The list to read\n * `list` - CByondValue array, allocated by caller (can be null if querying length)\n * `len` - Pointer to length of array (in items); receives the number of items read on success, or required length of array if not big enough\n # Returns\n\nTrue on success; false with *len=0 for failure; false with *len=required size if array is not big enough"]
	pub unsafe fn Byond_ReadListAssoc(
		&self,
		loc: *const CByondValue,
		list: *mut CByondValue,
		len: *mut u4c,
	) -> bool {
		(self.Byond_ReadListAssoc)(loc, list, len)
	}
	#[doc = "Reads an item from a list.\n Blocks if not on the main thread.\n # Arguments\n\n* `loc` - The list\n * `idx` - The index in the list (may be a number, or a non-number if using associative lists)\n * `result` - Pointer to accept result\n # Returns\n\nTrue on success"]
	pub unsafe fn Byond_ReadListIndex(
		&self,
		loc: *const CByondValue,
		idx: *const CByondValue,
		result: *mut CByondValue,
	) -> bool {
		(self.Byond_ReadListIndex)(loc, idx, result)
	}
	#[doc = "Writes an item to a list.\n Blocks if not on the main thread.\n # Arguments\n\n* `loc` - The list\n * `idx` - The index in the list (may be a number, or a non-number if using associative lists)\n * `val` - New value\n # Returns\n\nTrue on success"]
	pub unsafe fn Byond_WriteListIndex(
		&self,
		loc: *const CByondValue,
		idx: *const CByondValue,
		val: *const CByondValue,
	) -> bool {
		(self.Byond_WriteListIndex)(loc, idx, val)
	}
	#[doc = "Reads from a BYOND pointer\n Blocks if not on the main thread.\n # Arguments\n\n* `ptr` - The BYOND pointer\n * `result` - Pointer to accept result\n # Returns\n\nTrue on success"]
	pub unsafe fn Byond_ReadPointer(
		&self,
		ptr: *const CByondValue,
		result: *mut CByondValue,
	) -> bool {
		(self.Byond_ReadPointer)(ptr, result)
	}
	#[doc = "Writes to a BYOND pointer\n Blocks if not on the main thread.\n # Arguments\n\n* `ptr` - The BYOND pointer\n * `val` - New value\n # Returns\n\nTrue on success"]
	pub unsafe fn Byond_WritePointer(
		&self,
		ptr: *const CByondValue,
		val: *const CByondValue,
	) -> bool {
		(self.Byond_WritePointer)(ptr, val)
	}
	#[doc = "Calls an object proc by name.\n The proc call is treated as waitfor=0 and will return immediately on sleep.\n Blocks if not on the main thread.\n # Arguments\n\n* `src` - The object that owns the proc\n * `name` - Proc name as null-terminated string\n * `arg` - Array of arguments\n * `arg_count` - Number of arguments\n * `result` - Pointer to accept result\n # Returns\n\nTrue on success"]
	pub unsafe fn Byond_CallProc(
		&self,
		src: *const CByondValue,
		name: *const ::std::os::raw::c_char,
		arg: *const CByondValue,
		arg_count: u4c,
		result: *mut CByondValue,
	) -> bool {
		(self.Byond_CallProc)(src, name, arg, arg_count, result)
	}
	#[doc = "Calls an object proc by name, where the name is a string ID.\n The proc call is treated as waitfor=0 and will return immediately on sleep.\n Blocks if not on the main thread.\n # Arguments\n\n* `src` - The object that owns the proc\n * `name` - Proc name as string ID\n * `arg` - Array of arguments\n * `arg_count` - Number of arguments\n * `result` - Pointer to accept result\n # Returns\n\nTrue on success\n [`Byond_GetStrId()`]"]
	pub unsafe fn Byond_CallProcByStrId(
		&self,
		src: *const CByondValue,
		name: u4c,
		arg: *const CByondValue,
		arg_count: u4c,
		result: *mut CByondValue,
	) -> bool {
		(self.Byond_CallProcByStrId)(src, name, arg, arg_count, result)
	}
	#[doc = "Calls a global proc by name.\n The proc call is treated as waitfor=0 and will return immediately on sleep.\n Blocks if not on the main thread.\n # Arguments\n\n* `name` - Proc name as null-terminated string\n * `arg` - Array of arguments\n * `arg_count` - Number of arguments\n * `result` - Pointer to accept result\n # Returns\n\nTrue on success"]
	pub unsafe fn Byond_CallGlobalProc(
		&self,
		name: *const ::std::os::raw::c_char,
		arg: *const CByondValue,
		arg_count: u4c,
		result: *mut CByondValue,
	) -> bool {
		(self.Byond_CallGlobalProc)(name, arg, arg_count, result)
	}
	#[doc = "Calls a global proc by name, where the name is a string ID.\n The proc call is treated as waitfor=0 and will return immediately on sleep.\n Blocks if not on the main thread.\n # Arguments\n\n* `name` - Proc name as string ID\n * `arg` - Array of arguments\n * `arg_count` - Number of arguments\n * `result` - Pointer to accept result\n # Returns\n\nTrue on success\n [`Byond_GetStrId()`]"]
	pub unsafe fn Byond_CallGlobalProcByStrId(
		&self,
		name: u4c,
		arg: *const CByondValue,
		arg_count: u4c,
		result: *mut CByondValue,
	) -> bool {
		(self.Byond_CallGlobalProcByStrId)(name, arg, arg_count, result)
	}
	#[doc = "Uses BYOND's internals to represent a value as text\n Blocks if not on the main thread.\n # Arguments\n\n* `src` - The value to convert to text\n * `buf` - char array, allocated by caller (can be null if querying length)\n * `buflen` - Pointer to length of array in bytes; receives the string length (including trailing null) on success, or required length of array if not big enough\n # Returns\n\nTrue on success; false with *buflen=0 for failure; false with *buflen=required size if array is not big enough"]
	pub unsafe fn Byond_ToString(
		&self,
		src: *const CByondValue,
		buf: *mut ::std::os::raw::c_char,
		buflen: *mut u4c,
	) -> bool {
		(self.Byond_ToString)(src, buf, buflen)
	}
	#[doc = "Equivalent to calling block(x1,y1,z1, x2,y2,z2).\n Blocks if not on the main thread.\n # Arguments\n\n* `corner1` - One corner of the block\n * `corner2` - Another corner of the block\n * `list` - CByondValue array, allocated by caller (can be null if querying length)\n * `len` - Pointer to length of array (in items); receives the number of items read on success, or required length of array if not big enough\n # Returns\n\nTrue on success; false with *len=0 for failure; false with *len=required size if array is not big enough"]
	pub unsafe fn Byond_Block(
		&self,
		corner1: *const CByondXYZ,
		corner2: *const CByondXYZ,
		list: *mut CByondValue,
		len: *mut u4c,
	) -> bool {
		(self.Byond_Block)(corner1, corner2, list, len)
	}
	#[doc = "Equivalent to calling length(value).\n Blocks if not on the main thread.\n # Arguments\n\n* `src` - The value\n * `result` - Pointer to accept result as a CByondValue (intended for future possible override of length)\n # Returns\n\nTrue on success"]
	pub unsafe fn Byond_Length(&self, src: *const CByondValue, result: *mut CByondValue) -> bool {
		(self.Byond_Length)(src, result)
	}
	#[doc = "Equivalent to calling locate(type), or locate(type) in list.\n Blocks if not on the main thread.\n # Arguments\n\n* `type` - The type to locate\n * `list` - The list to locate in; can be a null pointer instead of a CByondValue to locate(type) without a list\n * `result` - Pointer to accept result; can be null if nothing is found\n # Returns\n\nTrue on success (including if nothing is found); false on error"]
	pub unsafe fn Byond_LocateIn(
		&self,
		type_: *const CByondValue,
		list: *const CByondValue,
		result: *mut CByondValue,
	) -> bool {
		(self.Byond_LocateIn)(type_, list, result)
	}
	#[doc = "Equivalent to calling locate(x,y,z)\n Blocks if not on the main thread.\n Result is null if coords are invalid.\n # Arguments\n\n* `xyz` - The x,y,z coords\n * `result` - Pointer to accept result\n # Returns\n\nTrue (always)"]
	pub unsafe fn Byond_LocateXYZ(&self, xyz: *const CByondXYZ, result: *mut CByondValue) -> bool {
		(self.Byond_LocateXYZ)(xyz, result)
	}
	#[doc = "Equivalent to calling new type(...)\n Blocks if not on the main thread.\n # Arguments\n\n* `type` - The type to create (type path or string)\n * `arg` - Array of arguments\n * `arg_count` - Number of arguments\n * `result` - Pointer to accept result\n # Returns\n\nTrue on success"]
	pub unsafe fn Byond_New(
		&self,
		type_: *const CByondValue,
		arg: *const CByondValue,
		arg_count: u4c,
		result: *mut CByondValue,
	) -> bool {
		(self.Byond_New)(type_, arg, arg_count, result)
	}
	#[doc = "Equivalent to calling new type(arglist)\n Blocks if not on the main thread.\n # Arguments\n\n* `type` - The type to create (type path or string)\n * `arglist` - Arguments, as a reference to an arglist\n * `result` - Pointer to accept result\n # Returns\n\nTrue on success"]
	pub unsafe fn Byond_NewArglist(
		&self,
		type_: *const CByondValue,
		arglist: *const CByondValue,
		result: *mut CByondValue,
	) -> bool {
		(self.Byond_NewArglist)(type_, arglist, result)
	}
	#[doc = "Equivalent to calling refcount(value)\n Blocks if not on the main thread.\n # Arguments\n\n* `src` - The object to refcount\n * `result` - Pointer to accept result\n # Returns\n\nTrue on success"]
	pub unsafe fn Byond_Refcount(&self, src: *const CByondValue, result: *mut u4c) -> bool {
		(self.Byond_Refcount)(src, result)
	}
	#[doc = "Get x,y,z coords of an atom\n Blocks if not on the main thread.\n # Arguments\n\n* `src` - The object to read\n * `xyz` - Pointer to accept CByondXYZ result\n # Returns\n\nTrue on success"]
	pub unsafe fn Byond_XYZ(&self, src: *const CByondValue, xyz: *mut CByondXYZ) -> bool {
		(self.Byond_XYZ)(src, xyz)
	}
	#[doc = "Get pixloc coords of an atom\n Blocks if not on the main thread.\n # Arguments\n\n* `src` - The object to read\n * `pixloc` - Pointer to accept CByondPixLoc result\n # Returns\n\nTrue on success"]
	pub unsafe fn Byond_PixLoc(&self, src: *const CByondValue, pixloc: *mut CByondPixLoc) -> bool {
		(self.Byond_PixLoc)(src, pixloc)
	}
	#[doc = "Get pixloc coords of an atom based on its bounding box\n Blocks if not on the main thread.\n # Arguments\n\n* `src` - The object to read\n * `dir` - The direction\n * `pixloc` - Pointer to accept CByondPixLoc result\n # Returns\n\nTrue on success"]
	pub unsafe fn Byond_BoundPixLoc(
		&self,
		src: *const CByondValue,
		dir: u1c,
		pixloc: *mut CByondPixLoc,
	) -> bool {
		(self.Byond_BoundPixLoc)(src, dir, pixloc)
	}
	#[doc = "Increase the persistent reference count of an object used in Byondapi\n Reminder: Calls only create temporary references when made on the main thread. On other threads, the references are already persistent.\n Blocks if not on the main thread.\n # Arguments\n\n* `src` - The object to incref"]
	pub unsafe fn ByondValue_IncRef(&self, src: *const CByondValue) {
		(self.ByondValue_IncRef)(src)
	}
	#[doc = "Mark a persistent reference as no longer in use by Byondapi\n This is IMPORTANT to call when you make Byondapi calls on another thread, since all the references they create are persistent.\n This cannot be used for temporary references. See ByondValue_DecTempRef() for those.\n Blocks if not on the main thread.\n # Arguments\n\n* `src` - The object to decref"]
	pub unsafe fn ByondValue_DecRef(&self, src: *const CByondValue) {
		(self.ByondValue_DecRef)(src)
	}
	#[doc = "Mark a temporary reference as no longer in use by Byondapi\n Temporary references will be deleted automatically at the end of a tick, so this only gets rid of the reference a little faster.\n Only works on the main thread. Does nothing on other threads.\n # Arguments\n\n* `src` - The object to decref"]
	pub unsafe fn ByondValue_DecTempRef(&self, src: *const CByondValue) {
		(self.ByondValue_DecTempRef)(src)
	}
	#[doc = "Test if a reference-type CByondValue is valid\n Blocks if not on the main thread.\n # Arguments\n\n* `src` - Pointer to the reference to test; will be filled with null if the reference is invalid\n # Returns\n\nTrue if ref is valid; false if not"]
	pub unsafe fn Byond_TestRef(&self, src: *mut CByondValue) -> bool {
		(self.Byond_TestRef)(src)
	}
	#[doc = "Causes a runtime error to crash the current proc\n Blocks if not on the main thread.\n # Arguments\n\n* `message` - Message to use as the runtime error"]
	pub unsafe fn Byond_CRASH(&self, message: *const ::std::os::raw::c_char) {
		(self.Byond_CRASH)(message)
	}
}
